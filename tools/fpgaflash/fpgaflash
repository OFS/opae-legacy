#! /usr/bin/env python
# Copyright(c) 2017, Intel Corporation
#
# Redistribution  and  use  in source  and  binary  forms,  with  or  without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of  source code  must retain the  above copyright notice,
#   this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
# * Neither the name  of Intel Corporation  nor the names of its contributors
#   may be used to  endorse or promote  products derived  from this  software
#   without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
# IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
# LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
# CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
# SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
# INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
# CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import argparse, struct, sys, tempfile, os, subprocess, re, filecmp, stat
from array import *
 
def check_rpd(ifile):
    data = ifile.read(0x20)
    pof_hdr = struct.unpack('IIIIIIII', data)
    for i in range(0, 3):
        if pof_hdr[i] != 0xffffffff:
            print "invalid rpd file"
            sys.exit(1)

    if pof_hdr[3] != 0x6a6a6a6a:
        print "invalid rpd file"
        sys.exit(1)

    return pof_hdr[4]

def reverse_bits(x, n):
    result = 0
    for i in xrange(n):
        if (x >> i) & 1: result |= 1 << (n - 1 - i)
    return result

def reverse_bits_in_file(ifile, ofile):
    bit_rev = array('B')
    for i in range(0, 256):
        bit_rev.append(reverse_bits(i, 8))

    while True:
        ichunk = ifile.read(4096)
        if not ichunk:
            break

        ochunk = ''
        for b in ichunk:
            ochunk += chr(bit_rev[ord(b)])
        ofile.write(ochunk)

def get_flash_size(mtd_debug, dev):
    try:
        mode = os.stat(args.device).st_mode
        if not stat.S_ISCHR(mode):
            print args.device, "is not a device file."

    except Exception as e:
        print "Couldn't open", args.device, ":", e
        sys.exit(1)

    output = subprocess.check_output([mtd_debug, "info", dev])
    regex = re.compile('mtd\.size = (\d+) ', re.MULTILINE)
    m = regex.search(output)
    if m:
        return int(m.group(1))
    else:
        print "could not find flash size"
        sys.exit(1)

def parse_args():
    descr = 'A tool to help update the flash used to configure an '
    descr += 'Intel FPGA at power up.'

    epi = 'example usage:\n\n'
    epi += '    fpgaflash user new_image.rpd /dev/mtd0 /usr/sbin/mtd_debug\n\n'
    epi += 'Use the output of \'ls -l /sys/class/mtd\' to help determine\n'
    epi += 'which device, /dev/mtd*.\n\n'

    parser = argparse.ArgumentParser(description=descr, epilog=epi,
                formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument('type', help = 'type of flash programming',
        choices = ['user', 'factory_that_can_brick_board'])
    parser.add_argument('file', help = 'rpd file to program into flash')
    parser.add_argument('device',
        help = 'mtd device to program (e.g. /dev/mtd0)')
    parser.add_argument('mtd_debug',
        help = 'full path to mtd_debug executable')
    return parser.parse_args()

if __name__ == "__main__":

    args = parse_args()

    if not os.path.isfile(args.mtd_debug):
        print args.mtd_debug + " is not a file."
        sys.exit(1)
    elif not os.access(args.mtd_debug, os.X_OK):
        print args.mtd_debug + " is not a executable."
        sys.exit(1)

    flash_size = get_flash_size(args.mtd_debug, args.device)

    print "flash size is " + str(flash_size)

    try:
        ifile = open(args.file, 'rb')
    except Exception as e:
        print "open() failed:", e
        sys.exit(1)

    start_addr = check_rpd(ifile)

    ofile = tempfile.NamedTemporaryFile(mode='wb', delete=False)

    if args.type == 'factory_that_can_brick_board':
        msg = "Are you sure you want to perform a factory update? [Yes/No]"
        sys.stdout.write(msg)
        line =  sys.stdin.readline()
        if line == "Yes\n":
            start_addr = 0
        else:
            sys.exit(1)

    ifile.seek(start_addr)

    print "reversing bits"
    reverse_bits_in_file(ifile, ofile)

    ifile.close()
    ofile.close()

    print "erasing flash"
    retval = subprocess.call([args.mtd_debug, "erase", args.device,
        str(start_addr), str(flash_size - start_addr)])

    if retval:
        print "failed to erase flash"
        os.remove(ofile.name)
        sys.exit(1)

    print "writing flash"
    retval = subprocess.call([args.mtd_debug, "write", args.device,
        str(start_addr), str(os.path.getsize(ofile.name)), ofile.name])

    if retval:
        print "failed to write flash"
        os.remove(ofile.name)
        sys.exit(1)

    vfile = tempfile.NamedTemporaryFile(mode='wb', delete=False)
    vfile.close()

    print "reading back flash"
    retval = subprocess.call([args.mtd_debug, "read", args.device,
        str(start_addr), str(os.path.getsize(ofile.name)), vfile.name])

    if retval:
        print "failed to read back flash"
        os.remove(ofile.name)
        os.remove(vfile.name)
        sys.exit(1)

    print "verifying flash"

    retval = filecmp.cmp(ofile.name, vfile.name)

    os.remove(ofile.name)
    os.remove(vfile.name)

    if retval:
        print "flash successfully verified"
    else:
        print "failed to verify flash"
        sys.exit(1)
